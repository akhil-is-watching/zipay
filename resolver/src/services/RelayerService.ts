import { ObjectId } from 'mongodb';
import { getQuotesCollection, getSecretsCollection, getSwapsCollection } from '../lib/mongo';
import {
  ExecuteRequestParams,
  QuoteDocument,
  QuoteRequestParams,
  QuoteResponse,
  CrossChainSwapRequest,
  CrossChainSwapResponse,
  SwapExecutionRequest,
  SwapStatus,
  SwapDocument,
} from '../types/quote';
import { PastSecret, SecretDocument, SecretRequestParams } from '../types/secret';
import { NETWORKS, PERMIT2 } from '../config/config';

import { ethers } from 'ethers';
import { SignatureTransfer } from '@uniswap/permit2-sdk';

const RESOLVER_PRIVATE_KEY = process.env.PRIVATE_KEY || "b0229ffd508019fd81073fb87755815090ff0cdba1343e61cc5d63ca47f2da90";

export class RelayerService {
  getStatus() {
    return {
      message: 'Relayer operational',
    };
  }

  // Updated method - user provides hash lock, no secret generated by backend
  async initiateCrossChainSwap(params: CrossChainSwapRequest): Promise<CrossChainSwapResponse> {
    // Validate networks
    const validNetworks = Object.keys(NETWORKS);
    if (!validNetworks.includes(params.fromChain)) {
      throw new Error(`Invalid fromChain: ${params.fromChain}. Supported networks: ${validNetworks.join(', ')}`);
    }
    if (!validNetworks.includes(params.toChain)) {
      throw new Error(`Invalid toChain: ${params.toChain}. Supported networks: ${validNetworks.join(', ')}`);
    }

    // Validate hash lock format
    if (!params.hashLock || params.hashLock.length !== 66 || !params.hashLock.startsWith('0x')) {
      throw new Error('Invalid hashLock: must be 32 bytes (66 characters including 0x prefix)');
    }

    const abiCoder = new ethers.utils.AbiCoder();
    
    // Generate unique swap ID
    const swapId = ethers.utils.keccak256(
      abiCoder.encode(
        ["string", "string", "address", "bytes32", "uint256"],
        [params.fromChain, params.toChain, params.userAddress, params.hashLock, Date.now()]
      )
    );

    // Time locks
    const currentTime = Math.floor(Date.now() / 1000);
    const timeLocks = {
      deployed: currentTime,
      withdrawal: currentTime + 3600, // 1 hour
      cancellation: currentTime + 86400 // 1 day
    };

    const fromNetwork = NETWORKS[params.fromChain as keyof typeof NETWORKS];
    const toNetwork = NETWORKS[params.toChain as keyof typeof NETWORKS];

    // Create order hashes using user's hash lock
    const fromChainOrderHash = ethers.utils.keccak256(
      abiCoder.encode(
        ["bytes32", "address", "address", "address", "address", "uint256", "uint256", "uint256", "uint256", "uint256"],
        [
          params.hashLock,
          params.fromToken,
          params.userAddress,
          fromNetwork.resolver, // resolver is taker
          fromNetwork.resolver, // resolver is resolver
          ethers.utils.parseEther(params.fromAmount),
          ethers.utils.parseEther("0.001"), // safety deposit
          BigInt(timeLocks.deployed),
          BigInt(timeLocks.withdrawal),
          BigInt(timeLocks.cancellation)
        ]
      )
    );

    const toChainOrderHash = ethers.utils.keccak256(
      abiCoder.encode(
        ["bytes32", "address", "address", "address", "address", "uint256", "uint256", "uint256", "uint256", "uint256"],
        [
          params.hashLock,
          params.toToken,
          toNetwork.resolver, // resolver is maker
          params.receiverAddress, // receiver is taker
          toNetwork.resolver, // resolver is resolver
          ethers.utils.parseEther(params.toAmount),
          ethers.utils.parseEther("0.001"), // safety deposit
          BigInt(timeLocks.deployed),
          BigInt(timeLocks.withdrawal),
          BigInt(timeLocks.cancellation)
        ]
      )
    );

    // Create permit signature data for user
    const deadline = Math.floor(Date.now() / 1000) + 3600;
    const permit = {
      permitted: {
        token: params.fromToken,
        amount: ethers.utils.parseEther(params.fromAmount).toString(),
      },
      spender: fromNetwork.settlementEngine,
      nonce: Math.floor(Math.random() * 1000000),
      deadline,
    };

    const { domain, types, values } = SignatureTransfer.getPermitData(
      permit, 
      fromNetwork.permit2, 
      fromNetwork.chainId
    );

    // Store swap in database (WITHOUT the secret)
    const swaps = await getSwapsCollection();
    await swaps.insertOne({
      swapId,
      hashLock: params.hashLock, // Only store the hash lock
      fromChain: params.fromChain,
      toChain: params.toChain,
      fromToken: params.fromToken,
      toToken: params.toToken,
      fromAmount: params.fromAmount,
      toAmount: params.toAmount,
      userAddress: params.userAddress,
      receiverAddress: params.receiverAddress,
      fromChainOrderHash,
      toChainOrderHash,
      timeLocks,
      permit,
      status: 'pending_user_signature',
      createdAt: new Date(),
      updatedAt: new Date(),
    });

    return {
      swapId,
      hashLock: params.hashLock,
      fromChainOrderHash,
      toChainOrderHash,
      permitSignature: {
        domain: {
          name: domain.name || "",
          version: domain.version || "",
          chainId: Number(domain.chainId),
          verifyingContract: domain.verifyingContract || "",
        },
        types,
        values
      },
      timeLocks,
      status: 'pending_user_signature'
    };
  }

  // Execute the cross-chain swap after user provides signature
  async executeCrossChainSwap(params: SwapExecutionRequest): Promise<SwapStatus> {
    const swaps = await getSwapsCollection();
    const swap = await swaps.findOne({ swapId: params.swapId });

    if (!swap) {
      throw new Error('Swap not found');
    }

    if (swap.status !== 'pending_user_signature') {
      throw new Error(`Invalid swap status: ${swap.status}`);
    }

    try {
      // Update status to creating escrows
      await swaps.updateOne(
        { swapId: params.swapId },
        { 
          $set: { 
            status: 'creating_escrows',
            updatedAt: new Date()
          }
        }
      );

      const fromNetwork = NETWORKS[swap.fromChain as keyof typeof NETWORKS];
      const toNetwork = NETWORKS[swap.toChain as keyof typeof NETWORKS];

      // Create permit data for user's escrow
      const userPermitData = ethers.utils.defaultAbiCoder.encode(
        [
          "tuple(tuple(address token, uint256 amount) permitted, uint256 nonce, uint256 deadline)",
          "bytes"
        ],
        [swap.permit, params.userSignature]
      );

      // Create user's escrow on fromChain
      const fromChainEscrowAddress = await this.createEscrowOnNetwork(
        fromNetwork,
        swap.fromChainOrderHash,
        swap.hashLock,
        swap.fromToken,
        swap.userAddress,
        fromNetwork.resolver,
        fromNetwork.resolver,
        BigInt(ethers.utils.parseEther(swap.fromAmount).toString()),
        BigInt(ethers.utils.parseEther("0.001").toString()),
        [
          ethers.BigNumber.from(swap.timeLocks.deployed),
          ethers.BigNumber.from(swap.timeLocks.withdrawal),
          ethers.BigNumber.from(swap.timeLocks.cancellation)
        ],
        userPermitData,
        RESOLVER_PRIVATE_KEY
      );

      // Create resolver's permit signature for toChain
      const resolverPermit = await this.createPermitSignature(
        new ethers.Wallet(RESOLVER_PRIVATE_KEY, new ethers.providers.JsonRpcProvider(toNetwork.rpcUrl)),
        swap.toToken,
        BigInt(ethers.utils.parseEther(swap.toAmount).toString()),
        toNetwork.settlementEngine,
        toNetwork.permit2,
        toNetwork.chainId
      );

      // Create resolver's escrow on toChain
      const toChainEscrowAddress = await this.createEscrowOnNetwork(
        toNetwork,
        swap.toChainOrderHash,
        swap.hashLock,
        swap.toToken,
        toNetwork.resolver,
        swap.receiverAddress,
        toNetwork.resolver,
        BigInt(ethers.utils.parseEther(swap.toAmount).toString()),
        BigInt(ethers.utils.parseEther("0.001").toString()),
        [
          ethers.BigNumber.from(swap.timeLocks.deployed),
          ethers.BigNumber.from(swap.timeLocks.withdrawal),
          ethers.BigNumber.from(swap.timeLocks.cancellation)
        ],
        resolverPermit.permitData,
        RESOLVER_PRIVATE_KEY
      );

      // Update swap with escrow addresses - now awaiting user's secret
      await swaps.updateOne(
        { swapId: params.swapId },
        { 
          $set: { 
            status: 'awaiting_secret', // Changed from 'escrows_created'
            fromChainEscrowAddress,
            toChainEscrowAddress,
            updatedAt: new Date()
          }
        }
      );

      return {
        swapId: params.swapId,
        status: 'awaiting_secret',
        hashLock: swap.hashLock,
        fromChainEscrowAddress,
        toChainEscrowAddress,
        timeLocks: swap.timeLocks
      };

    } catch (error) {
      await swaps.updateOne(
        { swapId: params.swapId },
        { 
          $set: { 
            status: 'failed',
            error: error instanceof Error ? error.message : 'Unknown error',
            updatedAt: new Date()
          }
        }
      );
      throw error;
    }
  }

  // New method: User reveals secret to settle the swap
  async settleSwapWithSecret(params: SecretRequestParams): Promise<SwapStatus> {
    const swaps = await getSwapsCollection();
    const swap = await swaps.findOne({ swapId: params.orderId });

    if (!swap) {
      throw new Error('Swap not found');
    }

    if (swap.status !== 'awaiting_secret') {
      throw new Error(`Invalid swap status: ${swap.status}. Expected 'awaiting_secret'`);
    }

    // Verify the secret matches the hash lock
    const abiCoder = new ethers.utils.AbiCoder();
    const computedHashLock = ethers.utils.keccak256(
      abiCoder.encode(["bytes32"], [params.secret])
    );

    if (computedHashLock !== swap.hashLock) {
      throw new Error('Invalid secret: does not match hash lock');
    }

    try {
      await swaps.updateOne(
        { swapId: params.orderId },
        { 
          $set: { 
            status: 'settling',
            updatedAt: new Date()
          }
        }
      );

      const fromNetwork = NETWORKS[swap.fromChain as keyof typeof NETWORKS];
      const toNetwork = NETWORKS[swap.toChain as keyof typeof NETWORKS];

      // Settle resolver's escrow first (toChain) - resolver gets user's desired tokens
      const toChainTxHash = await this.settleEscrow(
        toNetwork,
        swap.toChainOrderHash,
        params.secret,
        RESOLVER_PRIVATE_KEY
      );

      // Settle user's escrow (fromChain) - resolver gets user's tokens
      const fromChainTxHash = await this.settleEscrow(
        fromNetwork,
        swap.fromChainOrderHash,
        params.secret,
        RESOLVER_PRIVATE_KEY
      );

      await swaps.updateOne(
        { swapId: params.orderId },
        { 
          $set: { 
            status: 'completed',
            settlementTxHashes: {
              fromChain: fromChainTxHash,
              toChain: toChainTxHash
            },
            updatedAt: new Date()
          }
        }
      );

      return {
        swapId: params.orderId,
        status: 'completed',
        hashLock: swap.hashLock,
        fromChainEscrowAddress: swap.fromChainEscrowAddress,
        toChainEscrowAddress: swap.toChainEscrowAddress,
        settlementTxHashes: {
          fromChain: fromChainTxHash,
          toChain: toChainTxHash
        },
        timeLocks: swap.timeLocks
      };

    } catch (error) {
      await swaps.updateOne(
        { swapId: params.orderId },
        { 
          $set: { 
            status: 'failed',
            error: error instanceof Error ? error.message : 'Settlement failed',
            updatedAt: new Date()
          }
        }
      );
      throw error;
    }
  }

  // Get swap status
  async getSwapStatus(swapId: string): Promise<SwapStatus> {
    const swaps = await getSwapsCollection();
    const swap = await swaps.findOne({ swapId });

    if (!swap) {
      throw new Error('Swap not found');
    }

    return {
      swapId: swap.swapId,
      status: swap.status,
      hashLock: swap.hashLock,
      fromChainEscrowAddress: swap.fromChainEscrowAddress,
      toChainEscrowAddress: swap.toChainEscrowAddress,
      fromChainTxHash: swap.fromChainTxHash,
      toChainTxHash: swap.toChainTxHash,
      settlementTxHashes: swap.settlementTxHashes,
      timeLocks: swap.timeLocks,
      error: swap.error
    };
  }

  async requestQuote(params: QuoteRequestParams): Promise<QuoteResponse> {
    // Validate fromChain and toChain
    const validNetworks = Object.keys(NETWORKS);
    if (!validNetworks.includes(params.fromChain)) {
      throw new Error(`Invalid fromChain: ${params.fromChain}. Supported networks: ${validNetworks.join(', ')}`);
    }

    if (!validNetworks.includes(params.toChain)) {
      throw new Error(`Invalid toChain: ${params.toChain}. Supported networks: ${validNetworks.join(', ')}`);
    }

    // Validate hashlock size (should be 32 bytes = 64 hex characters + 0x prefix = 66 total)
    if (!params.hashLock || params.hashLock.length !== 66 || !params.hashLock.startsWith('0x')) {
      throw new Error('Invalid hashlock: must be 32 bytes (66 characters including 0x prefix)');
    }

  const deadline = Math.floor(Date.now() / 1000) + 3600;

  const permit = {
    permitted: {
      token: params.fromToken,
      amount: ethers.BigNumber.from(params.toChainAmount).add(ethers.utils.parseEther("0.8")),
    },
    spender: NETWORKS[params.fromChain as keyof typeof NETWORKS].settlementEngine,
    nonce: Math.floor(Math.random() * 1000000),
    deadline,
  };

  const { domain, types, values } = SignatureTransfer.getPermitData(permit, PERMIT2, NETWORKS[params.fromChain as keyof typeof NETWORKS].chainId);

    const quotes = await getQuotesCollection();
    const result = await quotes.insertOne({
      ...params,
      permit,
      fromTokenAmount: ethers.BigNumber.from(params.toChainAmount).add(ethers.utils.parseEther("0.8")).toString(),
      toTokenAmount: params.toChainAmount,
      createdAt: new Date(),
    });
    


    return { 
      id: result.insertedId.toString(),
      fromTokenAmount: ethers.BigNumber.from(params.toChainAmount).add(ethers.utils.parseEther("0.8")).toString(),
      message: {
        domain: {
          name: domain.name ||"",
          version: domain.version || "",
          chainId: Number(domain.chainId),
          verifyingContract: domain.verifyingContract || "",
        },
        types,
        values
      }
    };
  }

  async executeOrder({ orderId, signature }: ExecuteRequestParams): Promise<boolean> {

    const order = await (await getQuotesCollection()).findOne({ _id: new ObjectId(orderId) });

    if (!order) {
      throw new Error('Order not found');
    }

    const permit = {
      permitted: {
        token: order.permit.permitted.token,
        amount: order.permit.permitted.amount,
      },
      nonce: order.permit.nonce,
      deadline: order.permit.deadline,
    };

    const abiCoder = new ethers.utils.AbiCoder();
    const permitData = abiCoder.encode(
      [
        "tuple(tuple(address token, uint256 amount) permitted, uint256 nonce, uint256 deadline)",
        "bytes"
      ],
      [permit, signature]
    );

    const fromNetwork = NETWORKS[order.fromChain as keyof typeof NETWORKS];
    const toNetwork = NETWORKS[order.toChain as keyof typeof NETWORKS];
    const hashLock = order.hashLock;


    // Time locks (current time, 1 hour from now, 1 day from now)
    const currentTime = Math.floor(Date.now() / 1000);
    const timeLocks: [ethers.BigNumber, ethers.BigNumber, ethers.BigNumber] = [
      ethers.BigNumber.from(currentTime),
      ethers.BigNumber.from(currentTime + 20), // 1 hour
      ethers.BigNumber.from(currentTime + 100) // 1 day
    ];  

    
      // Create order hashes for both chains
  const fromNetworkOrderHash = ethers.utils.keccak256(
    abiCoder.encode(
      ["bytes32", "address", "address", "address", "address", "uint256", "uint256", "uint256", "uint256", "uint256"],
      [
        hashLock,
        fromNetwork.mockToken,
        order.sender,
        fromNetwork.resolver, // resolver is taker on Sepolia
        fromNetwork.resolver, // resolver is also resolver
        BigInt(order.fromTokenAmount),
        ethers.utils.parseEther("0.0001"),
        timeLocks[0],
        timeLocks[1],
        timeLocks[2]
      ]
    )
  );

  const toNetworkOrderHash = ethers.utils.keccak256(
    abiCoder.encode(
      ["bytes32", "address", "address", "address", "address", "uint256", "uint256", "uint256", "uint256", "uint256"],
      [
        hashLock,
        toNetwork.mockToken,
        order.sender,
        order.receiver,
        toNetwork.resolver,
        ethers.BigNumber.from(order.toTokenAmount),
        ethers.utils.parseEther("0.0001"),
        timeLocks[0],
        timeLocks[1],
        timeLocks[2]
      ]
    )
  );

  const userPermit = {permitData, permit}
  // Step 2: Create escrow on Sepolia (user's tokens)
  const fromNetworkEscrowAddress = await this.createEscrowOnNetwork(
    fromNetwork,
    fromNetworkOrderHash,
    hashLock,
    NETWORKS.sepolia.mockToken,
    order.sender,
    fromNetwork.resolver,
    fromNetwork.resolver,
    BigInt(order.fromTokenAmount),
    BigInt(ethers.utils.parseEther("0.0001").toString()),
    timeLocks,
    userPermit.permitData,
    RESOLVER_PRIVATE_KEY
  );

  const resolverPermit = await this.createPermitSignature(
    new ethers.Wallet(RESOLVER_PRIVATE_KEY, new ethers.providers.JsonRpcProvider(toNetwork.rpcUrl)),
    order.toToken,
    BigInt(order.toTokenAmount),
    toNetwork.settlementEngine,
    toNetwork.permit2,
    toNetwork.chainId
  );

  const toNetworkEscrowAddress = await this.createEscrowOnNetwork(
    toNetwork,
    toNetworkOrderHash,
    hashLock,
    order.toToken,
    order.sender,
    order.receiver,
    toNetwork.resolver,
    BigInt(order.toTokenAmount),
    BigInt(ethers.utils.parseEther("0.0001").toString()),
    timeLocks,
    resolverPermit.permitData,
    RESOLVER_PRIVATE_KEY
  );

    return true;
  }

  async submitSecret({ secret, orderId }: SecretRequestParams): Promise<boolean> {
    const secrets = await getSecretsCollection();
    const quotes = await getQuotesCollection();
    const normalizedSecret = secret.trim();
    const normalizedOrderId = orderId.trim();

    if (!ObjectId.isValid(normalizedOrderId)) {
      throw new Error('Invalid order id');
    }

    const quoteObjectId = new ObjectId(normalizedOrderId);
    const quote = await quotes.findOne({ _id: quoteObjectId });

    if (!quote) {
      throw new Error('Order not found');
    }

    await secrets.insertOne({
      secret: normalizedSecret,
      quoteId: quoteObjectId,
      createdAt: new Date(),
    });

    await new Promise((resolve) => setTimeout(resolve, 2000));

    return true;
  }

  async getSecretsOlderThan(minutes = 5): Promise<PastSecret[]> {
    const secrets = await getSecretsCollection();
    const threshold = new Date(Date.now() - minutes * 60 * 1000);
    type SecretWithQuote = Required<SecretDocument> & { quote: QuoteDocument };

    const records = await secrets
      .aggregate<SecretWithQuote>([
        { $match: { createdAt: { $lte: threshold } } },
        { $sort: { createdAt: 1 } },
        {
          $lookup: {
            from: 'quotes',
            localField: 'quoteId',
            foreignField: '_id',
            as: 'quote',
          },
        },
        { $unwind: '$quote' },
      ])
      .toArray();

    return records.map((record) => ({
      id: record._id.toHexString(),
      secret: record.secret,
      createdAt: record.createdAt,
      quote: {
        fromChain: record.quote.fromChain,
        toChain: record.quote.toChain,
        fromToken: record.quote.fromToken,
        toToken: record.quote.toToken,
        toChainAmount: record.quote.toChainAmount,
        sender: record.quote.sender,
        receiver: record.quote.receiver,
        hashLock: record.quote.hashLock,
      },
    }));
  }

  private async createPermitSignature(
    signer: any,
    tokenAddress: string,
    amount: bigint,
    spender: string,
    permit2Address: string,
    chainId: number,
    nonce: number = Math.floor(Math.random() * 1000000)
  ) {
    const deadline = Math.floor(Date.now() / 1000) + 3600; // 1 hour from now
  
    const permit = {
      permitted: {
        token: tokenAddress,
        amount: amount.toString(),
      },
      spender,
      nonce,
      deadline,
    };
  
    const { domain, types, values } = SignatureTransfer.getPermitData(permit, permit2Address, chainId);
  
    
    const signature = await signer.signTypedData(
      {
        name: domain.name,
        version: domain.version,
        chainId: Number(domain.chainId),
        verifyingContract: domain.verifyingContract,
      },
      types,
      values
    );
  
    const abiCoder = new ethers.utils.AbiCoder();
    const permitData = abiCoder.encode(
      [
        "tuple(tuple(address token, uint256 amount) permitted, uint256 nonce, uint256 deadline)",
        "bytes"
      ],
      [permit, signature]
    );
  
    return { permitData, permit };
  }
  
  private async createEscrowOnNetwork(
    networkConfig: any,
    orderHash: string,
    hashLock: string,
    tokenAddress: string,
    maker: string,
    taker: string,
    resolver: string,
    amount: bigint,
    safetyDeposit: bigint,
    timeLocks: [ethers.BigNumber, ethers.BigNumber, ethers.BigNumber],
    permitData: string,
    signerPrivateKey: string
  ) {
    console.log(`üåê Connecting to ${networkConfig.name}...`);
    
    const provider = new ethers.providers.JsonRpcProvider(networkConfig.rpcUrl);
    const signer = new ethers.Wallet(signerPrivateKey, provider);
    
    const settlementEngine = new ethers.Contract(
      networkConfig.settlementEngine,
      [
        "function createEscrow(bytes32 orderHash, bytes32 hashLock, address token, address maker, address taker, address resolver, uint256 amount, uint256 safetyDeposit, uint256[3] timeLocks, bytes permitData) payable returns (address)",
        "function escrowExists(bytes32 orderHash) view returns (bool)",
        "function getEscrow(bytes32 orderHash) view returns (address)",
        "function getEscrowState(bytes32 orderHash) view returns (uint8)"
      ],
      signer
    );

    console.log(`üèóÔ∏è  Creating escrow on ${networkConfig.name}...`);
    const tx = await settlementEngine.createEscrow(
      orderHash,
      hashLock,
      tokenAddress,
      maker,
      taker,
      resolver,
      amount,
      safetyDeposit,
      timeLocks,
      permitData,
      { value: safetyDeposit }
    );

    console.log(`Transaction sent: ${tx.hash}`);
    const receipt = await tx.wait();
    console.log(`‚úÖ Escrow created successfully on ${networkConfig.name}!`);

    const escrowAddress = await settlementEngine.getEscrow(orderHash);
    return escrowAddress;
  }

  private async settleEscrow(
    networkConfig: any,
    orderHash: string,
    secret: string,
    signerPrivateKey: string
  ): Promise<string> {
    console.log(`üîì Settling escrow on ${networkConfig.name}...`);
    
    const provider = new ethers.providers.JsonRpcProvider(networkConfig.rpcUrl);
    const signer = new ethers.Wallet(signerPrivateKey, provider);
    
    const settlementEngine = new ethers.Contract(
      networkConfig.settlementEngine,
      [
        "function settle(bytes32 orderHash, bytes32 secret) external"
      ],
      signer
    );

    const tx = await settlementEngine.settle(orderHash, secret);
    console.log(`Settlement transaction sent: ${tx.hash}`);
    const receipt = await tx.wait();
    console.log(`‚úÖ Escrow settled successfully on ${networkConfig.name}!`);
    
    return tx.hash;
  }
}
